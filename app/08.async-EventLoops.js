console.log("Topic: Async Event Loops");

// =====================Task ??===================================
// UA: Що собою представляє цикл подій? Наведіть приклад, як працює
//     цикл подій працює в JavaScript.
// EN: What is the event loop? Give an example of how the event loop
//     works in JavaScript.

/*
  Цикл подій є невід’ємною частиною середовища виконання JavaScript. Цикл   
  подій показує порядок обробки виконання асинхронних завдань, гарантуючи, 
  що вони не блокують основне виконання і дозволяють JavaScript бути постійно    
  дієвим. Давайте наведемо приклад, як цикл подій працює в JavaScript, 
  імітуючи асинхронну поведінку. Ось у якій черзі програма виконається:
*/

// console.log('Start'); // 1

// setTimeout(() => {
// 	console.log('Timeout1'); // 4
// }, 0);

// setTimeout(() => {
// 	console.log('Timeout2'); // 5
// }, 0);

// Promise.resolve().then(() => {
// 	console.log('Promise resolved'); // 3
// });

// console.log('End'); // 2

/*
  Програма запускається шляхом виводу 'Start' в консоль.
  Дві функції setTimeout() викликаються із затримкою в 0 мілісекунд.
  Хоча затримка кожної встановлена у значення 0, JavaScript розглядає 
  цю затримку як мінімальну, і яка додасть функцію callback спочатку до 
  черги завдань/подій і вже потім до стеку викликів (або стеку поточного 
  контексту виконання). Далі, викликається Promise.resolve().then(), 
  додаючи виклик callback до черги мікрозадач. Мікрозадачі, такі як  
  promise, мають вищий пріоритет ніж ті, які знаходяться у звичайній 
  черзі завдань/подій, тому promise буде виконуватись раніше і цикл 
  подій коли буде перевіряти чергу мікрозадач виконає зворотний виклик 
  Promise.resolve().then() та виведе в консоль 'Promise resolved'.
  Програма виводить 'End' в консоль.
  Далі цикл подій перевіряє стек викликів і виявляє, що він порожній.
  Потім цикл подій перевіряє чергу завдань і вибирає найстаріше завдання
  (в нашому випадку, це перший callback для виконання - перший setTimeout()).
  'Timeout1' виводиться у консоль.
  Цикл подій знову перевіряє стек викликів і виявляє, що він порожній.
  Цикл подій переходить до наступного завдання в черзі завдань і виконує
  другий зворотний виклик setTimeout(). 'Timeout2' виводиться у консоль.
  Цикл подій знову перевіряє стек викликів і виявляє, що він порожній.
*/

// Task 01
// UA: У якій послідовності будуть виведені значення? Поясніть результат.
// EN: In which sequence the result will be outputted? Explain the result.

// console.log(1);
// setTimeout(() => console.log(2), 10);
// const promise = new Promise((_resolve, reject) => {
//     console.log(3);
//     reject();
// })
//     .then(() => {
//         console.log(4);
//         console.log(5);
//     })
//     .then(() => console.log(6))
//     .catch(() => console.log(7))
// setTimeout(() => console.log(8), 0);
// console.log(9);
// promise.then(() => console.log(10));

// solution - output will be:
// 1, 3, 9, 7, 10, 8, 2

/* Виконання коду здійснюється в стеку виконання послідовно, рядок за рядком.
    Тобто перше буде виведення в консоль 1, далі йде макротаска із setTimeout
    яка має затримку в 10мс - ця такска переміститься в стек для макротасок.
    Потім в стеку виконання йде проміс - це мікротаска, яка буде виконана
    перед макротаскою і буде виведено 3 в консоль. Потім буде відхилення
    промісу і відповідно метод then із виведенням 4 та 5 і метод then із 
    виведенням 6, в консоль не будуть виведені, але через наявність в методі
    catch console.log буде виведено 7. Після цього йде знову макротаска із 
    setTimeout, яка буде переміщена в стек макротасок але перед попередньою
    задачею бо має нульову затримку. В стеку виконання буде виведено 9 і 
    далі резолвиться проміс який виведе в консоль 10. Як тільки стек для 
    виконання очиститься, туда буде переміщено задачі зі стеку макротасок.
    Першим буде виведено 8 і через 10мс виведеться 2.
*/
